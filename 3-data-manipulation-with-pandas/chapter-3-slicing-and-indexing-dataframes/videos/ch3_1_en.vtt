WEBVTT

1
00:00:00.000 --> 00:00:05.640
In chapter one, you saw that DataFrames are composed of three parts: a

2
00:00:05.640 --> 00:00:11.640
NumPy array for the data, and two indexes to store the row and column details.

3
00:00:11.640 --> 00:00:11.640


4
00:00:11.640 --> 00:00:11.640


5
00:00:11.640 --> 00:00:14.040
Here's the dog dataset again.

6
00:00:14.040 --> 00:00:14.040


7
00:00:14.040 --> 00:00:14.080


8
00:00:14.080 --> 00:00:16.240
Recall that dot-columns contains an

9
00:00:16.240 --> 00:00:23.320
Index object of column names, and dot-index contains an Index object of row numbers.

10
00:00:23.320 --> 00:00:23.320


11
00:00:23.320 --> 00:00:23.320


12
00:00:23.320 --> 00:00:27.640
You can move a column from the body of the DataFrame to the index.

13
00:00:27.640 --> 00:00:33.600
This is called "setting an index," and it uses the set_index method.

14
00:00:33.600 --> 00:00:33.600


15
00:00:33.600 --> 00:00:33.600


16
00:00:33.600 --> 00:00:39.440
Notice that the output has changed slightly; in particular, a quick visual clue that

17
00:00:39.440 --> 00:00:46.840
name is now in the index is that the index values are left-aligned rather than right-aligned.

18
00:00:46.840 --> 00:00:46.840


19
00:00:46.840 --> 00:00:46.840


20
00:00:46.840 --> 00:00:53.320
To undo what you just did, you can reset the index - that is, you remove it.

21
00:00:53.320 --> 00:00:57.080
This is done via reset_index.

22
00:00:57.080 --> 00:00:57.080


23
00:00:57.080 --> 00:00:57.120


24
00:00:57.120 --> 00:01:03.240
reset_index has a drop argument that allows you to discard an index.

25
00:01:03.240 --> 00:01:08.760
Here, setting drop to True entirely removes the dog names.

26
00:01:08.760 --> 00:01:08.760


27
00:01:08.760 --> 00:01:08.760


28
00:01:08.760 --> 00:01:12.400
You may be wondering why you should bother with indexes.

29
00:01:12.400 --> 00:01:15.360
The answer is that it makes subsetting code cleaner.

30
00:01:15.360 --> 00:01:22.680
Consider this example of subsetting for the rows where the dog is called Bella or Stella.

31
00:01:22.680 --> 00:01:25.840
It's a fairly tricky line of code for such a simple task.

32
00:01:25.840 --> 00:01:25.840


33
00:01:25.840 --> 00:01:27.240


34
00:01:27.240 --> 00:01:30.360
Now, look at the equivalent when the names are in the index.

35
00:01:30.360 --> 00:01:37.800
DataFrames have a subsetting method called "loc," which filters on index values.

36
00:01:37.800 --> 00:01:41.880
Here you simply pass the dog names to loc as a list.

37
00:01:41.880 --> 00:01:44.520
Much easier!

38
00:01:44.520 --> 00:01:44.520


39
00:01:44.520 --> 00:01:44.520


40
00:01:44.520 --> 00:01:47.600
The values in the index don't need to be unique.

41
00:01:47.600 --> 00:01:50.000
Here, there are two Labradors in the index.

42
00:01:50.000 --> 00:01:51.680


43
00:01:51.680 --> 00:01:51.680


44
00:01:51.680 --> 00:01:58.080
Now, if you subset on "Labrador" using loc, all the Labrador data is returned.

45
00:01:58.080 --> 00:01:58.080


46
00:01:58.080 --> 00:01:58.080


47
00:01:58.080 --> 00:02:03.520
You can include multiple columns in the index by passing a list of column names to set_index.

48
00:02:03.520 --> 00:02:06.960
Here, breed and color are included.

49
00:02:06.960 --> 00:02:13.840
These are called multi-level indexes, or hierarchical indexes: the terms are synonymous.

50
00:02:13.840 --> 00:02:13.840


51
00:02:13.840 --> 00:02:15.000


52
00:02:15.000 --> 00:02:17.560
There is an implication here that the inner level of

53
00:02:17.560 --> 00:02:22.480
index, in this case, color, is nested inside the outer level, breed.

54
00:02:22.480 --> 00:02:22.480


55
00:02:22.480 --> 00:02:22.480


56
00:02:22.480 --> 00:02:29.720
To take a subset of rows at the outer level index, you pass a list of index values to loc.

57
00:02:29.720 --> 00:02:38.440
Here, the list contains Labrador and Chihuahua, and the resulting subset contains all dogs from both breeds.

58
00:02:38.440 --> 00:02:38.440


59
00:02:38.440 --> 00:02:38.440


60
00:02:38.440 --> 00:02:43.840
To subset on inner levels, you need to pass a list of tuples.

61
00:02:43.840 --> 00:02:50.960
Here, the first tuple specifies Labrador at the outer level and Brown at the inner level.

62
00:02:50.960 --> 00:02:50.960


63
00:02:50.960 --> 00:02:50.960


64
00:02:50.960 --> 00:02:55.560
The resulting rows have to match all conditions from a tuple.

65
00:02:55.560 --> 00:03:01.520
For example, the black Labrador wasn't returned because the brown condition wasn't matched.

66
00:03:01.520 --> 00:03:02.960


67
00:03:02.960 --> 00:03:02.960


68
00:03:02.960 --> 00:03:08.080
In chapter 1, you saw how to sort the rows of a DataFrame using sort_values.

69
00:03:08.080 --> 00:03:13.960
You can also sort by index values using sort_index.

70
00:03:13.960 --> 00:03:19.240
By default, it sorts all index levels from outer to inner, in ascending order.

71
00:03:19.240 --> 00:03:19.240


72
00:03:19.240 --> 00:03:19.240


73
00:03:19.240 --> 00:03:26.400
You can control the sorting by passing lists to the level and ascending arguments.

74
00:03:26.400 --> 00:03:26.400


75
00:03:26.400 --> 00:03:26.400


76
00:03:26.400 --> 00:03:30.480
Indexes are controversial.

77
00:03:30.480 --> 00:03:34.160
Although they simplify subsetting code, there are some downsides.

78
00:03:34.160 --> 00:03:34.160


79
00:03:34.160 --> 00:03:34.160


80
00:03:34.160 --> 00:03:36.760
Index values are just data.

81
00:03:36.760 --> 00:03:41.280
Storing data in multiple forms makes it harder to think about.

82
00:03:41.280 --> 00:03:41.280


83
00:03:41.280 --> 00:03:41.280


84
00:03:41.280 --> 00:03:47.920
There is a concept called "tidy data," where data is stored in tabular form - like a DataFrame.

85
00:03:47.920 --> 00:03:53.800
Each row contains a single observation, and each variable is stored in its own column.

86
00:03:53.800 --> 00:03:59.640
Indexes violate the last rule since index values don't get their own column.

87
00:03:59.640 --> 00:03:59.640


88
00:03:59.640 --> 00:03:59.640


89
00:03:59.640 --> 00:04:06.520
In pandas, the syntax for working with indexes is different from the syntax for working with columns.

90
00:04:06.520 --> 00:04:12.680
By using two syntaxes, your code is more complicated, which can result in more bugs.

91
00:04:12.680 --> 00:04:12.680


92
00:04:12.680 --> 00:04:12.680


93
00:04:12.680 --> 00:04:17.280
If you decide you don't want to use indexes, that's perfectly reasonable.

94
00:04:17.280 --> 00:04:23.000
However, it's useful to know how they work for cases when you need to read other people's code.

95
00:04:23.000 --> 00:04:23.000


96
00:04:23.000 --> 00:04:23.000


97
00:04:23.000 --> 00:04:29.720
In this chapter, you'll work with a monthly time series of air temperatures in cities around the world.

98
00:04:29.720 --> 00:04:29.720


99
00:04:29.720 --> 00:04:29.720


100
00:04:29.720 --> 00:04:34.440
Let's get indexing!

